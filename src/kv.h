#pragma once

// - Standard C
#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// - System specific
#include <fcntl.h>
#include <limits.h>
#include <semaphore.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>

// - Macro to inhibit unused variable warnings
#define UNUSED(expr)  \
    do {              \
        (void)(expr); \
    } while(0)

// - Constants
#define BUCKET_COUNT 256
#define BUCKET_SIZE 512
#define KEY_COUNT 16
#define KEY_SIZE 32

#define MY_TRUE 1
#define MY_FALSE 0

#define MY_OK 0
#define MY_ERR -1
#define MY_ERR_ARG -2

// - Data types
typedef struct bucket {
    char keys[BUCKET_SIZE][KEY_COUNT];  //!< Keys
    char values[BUCKET_SIZE][KEY_SIZE]; //!< Values
    int cache_valid;                    //!< Cache validity
    sem_t protect;                      //!< Lock for bucket synchronisation
} bucket_t;

typedef struct store {
    bucket_t buckets[BUCKET_COUNT]; //!< Bucket list
    sem_t protect;                  //!< Lock for store synchronisation
    int clients;                    //!< Number of attached clients
    char name[NAME_MAX];            //!< Name of the store
} store_t;

/**
 * @brief String hashing function
 * @param word String to hash
 * @param max Upper bound for the index produced
 * @return Index in [0, max[
 */
size_t hash_func(char* word, int32_t max);

// - Internal memory management

/**
 * @brief Creates or attaches to an existing shared memory object
 * @param fd File descriptor to be filled in after the call to this function
 * @param name Name of the shared memory object
 * @param flags File flags used for the store
 * @param perms File mode used for the store
 * @param clear Set 'clear' to MY_TRUE to clear the store or MY_FALSE otherwise.
 * @return MY_OK if a shared memory object is created and Non MY_OK otherwise
 */
int sm_create(int* fd, char* name, int flags, mode_t perms, int clear);

/**
 * @brief Checks if a shared memory object exists
 * @param name Name of the shared memory object
 * @return MY_OK if a shared memory object exists and Non MY_OK otherwise
 */
int sm_exists(char* name);

/**
 * @brief Maps a shared memory object for access in the current process
 * @param fd File descriptor generated by 'sm_create' call
 * @param shm Address of the pointer used for accessing shared memory object
 * @return MY_OK on success and Non MY_OK otherwise
 */
int sm_attach(int fd, store_t** shm);

/**
 * @brief Un-maps a shared memory object from the current process
 * @param shm Address of the pointer used for accessing shared memory object
 * @return MY_OK on success and Non MY_OK otherwise
 */
int sm_detach(store_t** shm);

/**
 * @brief Deletes the shared memory object
 * @param name Name of the shared memory object
 * @return MY_OK on success and Non MY_OK otherwise
 */
int sm_close(char* name);

// - Interface

/**
 * @brief Creates or attaches to a store called 'name'
 * @param name Name of the store
 * @return -1 on error and 0 on success
 */
int kv_store_create(char* name);

/**
 * @brief Adds a value to a key. Since the size of the store is fixed, older
 * values are evicted using FIFO order. Many values are stored for a key.
 * @param key Key
 * @param value Value
 * @return -1 on error and 0 on success
 */
int kv_store_write(char* key, char* value);

/**
 * @brief Returns a value associated with a key. If many values are stored, this
 * function cycles though them. Writing to a store resets the position of the
 * item returned.
 * @param key Key
 * @return NULL on error and Non NULL on success
 */
char* kv_store_read(char* key);

/**
 * @brief Returns all values associated with a key.
 * @param key Key
 * @return NULL on error and Non NULL on success
 */
char** kv_store_read_all(char* key);

/**
 * @brief Deletes the store called 'name'
 * @param name Name of the store
 * @return -1 on error and 0 on success
 */
int kv_store_destroy(char* name);

/**
 * @brief Deletes the global store
 * @return -1 on error and 0 on success
 */
int kv_delete_db(void);

/**
 * @brief Prints the contents of the current store to stdout
 */
void kv_store_print(void);
